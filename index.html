<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Twitch Blackjack Overlay</title>
<script src="https://cdn.jsdelivr.net/npm/tmi.js/dist/tmi.min.js"></script>
<style>
:root{
  --bg:#0c0f14; --panel:#121826; --accent:#20d3a6; --muted:#9aa4b2; --text:#eef2f7;
  --good:#45e39a; --bad:#ff6b6b; --warn:#ffb454; --card:#12203a; --outline:#2f3a5a;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
  font-family:Inter,system-ui,Segoe UI,Roboto,Arial;overflow:hidden}
.wrap{max-width:1920px;margin:auto;padding:12px;position:relative}

/* Top bar (fixed, single line if possible) */
.topbar{
  position:fixed;top:0;left:0;right:0;z-index:300;
  display:flex;gap:8px;align-items:center;flex-wrap:wrap;
  background:#111a2c;padding:8px 10px;border-bottom:1px solid rgba(255,255,255,.08)
}
.topbar input{width:200px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,.08);
  background:#0f1422;color:var(--text)}
.btn{background:var(--accent);color:#041a16;border:none;padding:6px 10px;border-radius:8px;
  font-weight:800;cursor:pointer;white-space:nowrap}
.btn.alt{background:#253152;color:#dfe7f1}
.badge{background:#1a233c;border:1px solid rgba(255,255,255,.1);
  padding:4px 8px;border-radius:999px;font-size:12px;white-space:nowrap}

/* Layout */
.layout{display:grid;grid-template-columns:280px 1fr 320px;gap:12px;margin-top:60px}
.panel{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);
  border-radius:12px;padding:10px}
.table{background:#0f1527;border:1px solid rgba(255,255,255,.08);
  border-radius:12px;padding:12px;overflow:hidden;position:relative}

.rules{font-size:12px;line-height:1.45}
.rules h3{margin:0 0 6px 0}

/* Dealer & table */
.dealer{margin-bottom:10px;padding:8px;border:1px dashed rgba(255,255,255,.16);border-radius:10px}
.row{display:flex;gap:8px;flex-wrap:wrap}
.cards{display:flex;gap:4px;flex-wrap:wrap}
.card{width:46px;height:64px;border-radius:6px;background:var(--card);
  border:1px solid rgba(255,255,255,.1);display:flex;align-items:center;justify-content:center;
  font-size:14px;font-weight:800;letter-spacing:.02em}
.card.red{color:#ff8a8a}
.card.hidden{background:linear-gradient(135deg,#1d2a52,#0f1732);border-color:#1b2446}

/* Players */
.handgrid{display:flex;gap:8px;flex-wrap:wrap}
.handbox{flex:1 1 220px;min-width:204px;background:rgba(255,255,255,.03);
  border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:8px;position:relative}
.handbox.active{box-shadow:0 0 0 2px var(--accent) inset}
.handhead{display:flex;justify-content:space-between;align-items:baseline;margin-bottom:4px}
.name{font-weight:800}
.bank{font-size:12px;color:#cfe4ff}
.timer{font-size:12px;font-weight:800;color:var(--warn);margin-top:2px}
.status{font-size:12px;color:var(--muted);min-height:16px;margin-top:2px}
.scorechip{position:absolute;top:6px;right:6px;background:#142038;border:1px solid var(--outline);
  border-radius:999px;padding:2px 6px;font-size:11px;font-weight:800;color:#dfe7ff}

/* Result badges */
.result.win{color:var(--good)} .result.lose{color:var(--bad)} .result.push{color:var(--warn)}

/* Right column lists */
.list{max-height:220px;overflow:auto;font-size:13px;border:1px solid rgba(255,255,255,.08);
  border-radius:8px;background:#0f1422}
.line{padding:6px 8px;border-bottom:1px solid rgba(255,255,255,.06)}
.chat{max-height:320px;overflow:auto;background:#0f1422;border-radius:8px;
  border:1px solid rgba(255,255,255,.08);padding:6px}
.chat .msg{font-size:12px;color:#d1d7e6;border-bottom:1px solid rgba(255,255,255,.06);padding:3px 2px}

/* Flash overlay */
.flash{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  background:rgba(32,211,166,0.96);color:#041a16;padding:16px 24px;border-radius:14px;
  font-size:18px;font-weight:800;opacity:0;pointer-events:none;
  transition:opacity .25s ease;z-index:200;max-width:92%;text-align:center}
.flash.show{opacity:1}

/* Bet summary strip */
.betsummary{margin-top:6px;font-size:12px;color:#cfe4ff}

/* Compact mode (>10 players) with mini action log */
.compact .handbox{flex:1 1 150px;min-width:150px;max-width:150px;padding:6px}
.compact .cards{min-height:48px}
.compact .card{width:30px;height:44px;font-size:12px}
.minilog{
  position:absolute;bottom:6px;left:6px;right:6px;font-size:10px;line-height:1.15;
  background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.15);border-radius:6px;
  padding:4px 6px;color:#dde3f3;max-height:46px;overflow:hidden
}
.minilog .entry{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
</style>
</head>
<body>
<div class="wrap">
  <!-- FIXED TOPBAR -->
  <div class="topbar">
    <input id="channelInput" type="text" placeholder="Twitch channel (e.g. ryaah)">
    <button id="connectBtn" class="btn">Connect</button>
    <button id="startBtn" class="btn">Start Round</button>
    <button id="stopBtn" class="btn alt">Stop Round</button>
    <button id="resetBalancesBtn" class="btn alt">Reset Balances</button>
    <button id="resetEarningsBtn" class="btn alt">Reset Leaderboard</button>
    <button id="modeBtn" class="btn alt" title="Toggle before starting a round">Mode: Turn-Based</button>
    <span class="badge" id="conn">Not connected</span>
    <span class="badge" id="modeNote">Queue: 0 · Ready</span>
  </div>

  <div class="layout">
    <!-- LEFT: RULES (PINNED) -->
    <div class="panel rules">
      <h3>Rules</h3>
      <ul>
        <li><b>!join</b> to enter the queue · <b>!leave</b> to leave</li>
        <li><b>!bet 10..1000</b> or <b>!bet all</b> (before start)</li>
        <li><b>!hit</b> to draw · <b>!stand</b> to hold</li>
        <li><b>!give 50 user</b> / <b>!give all user</b> (before start)</li>
        <li><b>!money</b> to show your balance</li>
        <li>Mods: <b>!add 200 user</b> · <b>!addall 100</b> (before start)</li>
        <li>Timers: 20s per decision (both modes)</li>
      </ul>
      <div class="line" style="margin-top:6px;font-size:11px;color:#9fb3d9">
        Economy: bets lock at start. Wins pay <b>2× bet</b> (net +bet), push refunds bet, loses get nothing.
        Leaderboard shows all-time profit.
      </div>
    </div>

    <!-- CENTER: TABLE -->
    <div id="tablePanel" class="table panel">
      <div class="dealer">
        <div class="row" style="justify-content:space-between;align-items:center">
          <div><b>Dealer</b> <span id="dealerScore">-</span></div>
          <div id="roundInfo">Waiting for queue — type !join</div>
        </div>
        <div class="betsummary" id="betSummary" style="display:none"></div>
        <div class="cards" id="dealerCards" style="margin-top:6px"></div>
      </div>

      <div id="playersRow" class="handgrid"></div>
      <div id="flashMsg" class="flash"></div>
    </div>

    <!-- RIGHT: QUEUE / CHAT / LEADERBOARD -->
    <div>
      <div class="panel"><h3>Queue</h3><div id="queueList" class="list"></div></div>
      <div class="panel"><h3>Chat</h3><div id="chatBox" class="chat"></div></div>
      <div class="panel"><h3>Leaderboard (Top 5)</h3><div id="earningsBoard" class="list"></div></div>
    </div>
  </div>
</div>

<script>
/* ===================== CONFIG & STATE ===================== */
const START_BALANCE = 1000;
const TURN_TIMEOUT  = 30;     // seconds per decision (both modes)
const MAX_BET       = 5000;   // UI rule cap; players can bet 'all' up to their balance
const MOD_BADGES = ['broadcaster','moderator'];

// session
let client=null, connectedChannel='';
let inRound=false, playMode='turn', lockedMode=null;

// shoe & dealer
let shoe=[], dealer={hand:[], reveal:false};

// players / queue
let queue=[];                // awaiting next round
let activePlayers=[];        // seated for this round [{name,hand,result,done,elim,timeLeft,log:[],timer?}]
let turnIdx=-1, turnTimer=null;

// economy
let balances={};             // {user: balance}
let bets={};                 // locked bet per user (pre-round)
let earningsBucketKey='bjEarnings:global'; // overwritten per channel after connect
let earnings = {};           // {user: all-time profit} (stored per channel)

/* ===================== UTILS ===================== */
const $=id=>document.getElementById(id);
const norm=(s)=>String(s||'').trim();
function isModOrBroadcaster(tags){
  if(tags.badges){
    return Object.keys(tags.badges).some(b=>MOD_BADGES.includes(b));
  }
  return !!(tags.mod || tags['user-type']==='mod');
}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}}
function buildShoe(){const R=['A','2','3','4','5','6','7','8','9','10','J','Q','K'],S=['♠','♥','♦','♣'];shoe=[];for(let d=0;d<6;d++)for(const r of R)for(const s of S)shoe.push({r,s});shuffle(shoe);}
function draw(){if(shoe.length===0)buildShoe();return shoe.pop();}
function bestValue(cards){let t=0,a=0;for(const c of cards){if(c.r==='A'){a++;t+=11;}else if(['10','J','Q','K'].includes(c.r))t+=10;else t+=+c.r;}while(t>21&&a>0){t-=10;a--;}return t;}
function isSoft(cards){let t=0,a=0;for(const c of cards){if(c.r==='A'){a++;t+=11;}else if(['10','J','Q','K'].includes(c.r))t+=10;else t+=+c.r;}while(t>21&&a>0){t-=10;a--;}return a>0;}
function cardEl(c,h=false){const d=document.createElement('div');d.className='card'+((c?.s==='♥'||c?.s==='♦')?' red':'');if(h){d.classList.add('hidden');return d;}d.textContent=c.r+c.s;return d;}
function flashMessage(msg){const f=$('flashMsg');f.innerHTML=msg;f.classList.add('show');setTimeout(()=>f.classList.remove('show'),2200);}
function saveEarnings(){localStorage.setItem(earningsBucketKey,JSON.stringify(earnings));}
function loadEarnings(){const raw=localStorage.getItem(earningsBucketKey);earnings=raw?JSON.parse(raw):{};}

/* ===================== RENDER ===================== */
function renderEarnings(){
  const top=Object.entries(earnings).sort((a,b)=>b[1]-a[1]).slice(0,5);
  $('earningsBoard').innerHTML = top.length
    ? top.map(([n,v],i)=>`<div class="line">${i+1}. ${n} — $${v}</div>`).join('')
    : '<div class="line">No earnings yet</div>';
}
function updateModeNote(){
  $('modeNote').textContent = `Queue: ${queue.length} · ${inRound?('Mode: '+(lockedMode==='turn'?'Turn-Based':'All-at-Once')):'Ready'}`;
  $('modeBtn').disabled = inRound; // can toggle anytime BEFORE start
}
function render(){
  // compact toggle
  const panel=$('tablePanel');
  if(activePlayers.length>10) panel.classList.add('compact'); else panel.classList.remove('compact');

  // dealer
  const dc=$('dealerCards'); dc.innerHTML='';
  (dealer.hand||[]).forEach((c,i)=>dc.appendChild(cardEl(c, !dealer.reveal && i===1)));
  $('dealerScore').textContent = dealer.reveal ? bestValue(dealer.hand||[]) : (dealer.hand?.[0] ? bestValue([dealer.hand[0]]) : '-');

  // players
  const row=$('playersRow'); row.innerHTML='';
  activePlayers.forEach((p,i)=>{
    const box=document.createElement('div'); box.className='handbox';
    if(lockedMode==='turn' && inRound && i===turnIdx) box.classList.add('active');

    const head=document.createElement('div'); head.className='handhead';
    head.innerHTML=`<span class="name">${p.name}</span><span class="bank">$${balances[p.name]??START_BALANCE}</span>`;

    const cards=document.createElement('div'); cards.className='cards';
    (p.hand||[]).forEach(c=>cards.appendChild(cardEl(c)));

    const status=document.createElement('div'); status.className='status';
    const total = bestValue(p.hand||[]);
    if(p.result){
      status.innerHTML = `<span class="result ${p.result.type}">${p.result.text}</span> · cards = <b>${total}</b>`;
    } else {
      const timerTxt = (inRound ? ` · ⏳ ${p.timeLeft??TURN_TIMEOUT}s` : '');
      status.innerHTML = `cards = <b>${total}</b>${timerTxt}`;
    }

    const chip=document.createElement('div'); chip.className='scorechip'; chip.textContent = total;

    box.append(head,cards,status,chip);

    // mini action log in compact mode
    if(activePlayers.length>10){
      const logBox=document.createElement('div'); logBox.className='minilog';
      const recent=(p.log||[]).slice(-5);
      logBox.innerHTML = recent.length ? recent.map(e=>`<div class="entry">• ${e}</div>`).join('') : `<div class="entry">No actions</div>`;
      box.appendChild(logBox);
    }

    row.appendChild(box);
  });

  // queue (show pre-locked bets beside name)
  $('queueList').innerHTML = queue.length
    ? queue.map((n,i)=>`<div class="line">${i+1}. ${n}${bets[n]?` · $${bets[n]}`:''}</div>`).join('')
    : '<div class="line">Queue empty</div>';

  renderEarnings();
  updateModeNote();
}

/* ===================== QUEUE & ECON ===================== */
function ensureBalance(u){ if(!(u in balances)) balances[u]=START_BALANCE; }
function addLog(p,text){ p.log=p.log||[]; p.log.push(text); if(p.log.length>12) p.log.shift(); }

function joinCommand(user){
  ensureBalance(user);
  if(inRound){
    if(!queue.includes(user) && !activePlayers.some(p=>p.name.toLowerCase()===user.toLowerCase())){
      queue.push(user); flashMessage(`${user} queued for next round`);
    }
  }else{
    if(!queue.includes(user)) { queue.push(user); flashMessage(`${user} joined the queue`); }
  }
  render();
}
function leaveCommand(user){
  queue = queue.filter(u=>u.toLowerCase()!==user.toLowerCase());
  flashMessage(`${user} left the queue`);
  render();
}
function betCommand(user, amtStr){
  if(inRound){ flashMessage('Bets are locked'); return; }
  ensureBalance(user);
  let amt;
  if(!amtStr || amtStr.toLowerCase()==='all') amt = balances[user];
  else { amt = Math.max(10, Math.min(MAX_BET, Math.floor(+amtStr||10))); }
  if(amt<=0){ flashMessage(`${user} has no funds`); return; }
  if(amt>balances[user]) amt = balances[user]; // all-in limited by balance
  bets[user] = amt;
  flashMessage(`${user} bet $${amt}`);
  render();
}
function giveCommand(from, amtStr, to){
  if(inRound){ flashMessage('Transfers only before round'); return; }
  if(!to){ flashMessage('Usage: !give <amt|all> <user>'); return; }
  ensureBalance(from); ensureBalance(to);
  let amt = (amtStr && amtStr.toLowerCase()==='all') ? balances[from] : Math.floor(+amtStr||0);
  if(amt<=0 || balances[from]<amt){ flashMessage(`${from} insufficient funds`); return; }
  balances[from]-=amt; balances[to]+=amt;
  flashMessage(`${from} gave $${amt} to ${to}`);
  render();
}
function addCommand(modTags, amtStr, user){
  if(!isModOrBroadcaster(modTags)) return;
  const amt=Math.floor(+amtStr||0); if(!user||amt<=0){ flashMessage('Usage: !add <amt> <user>'); return; }
  ensureBalance(user); balances[user]+=amt;
  flashMessage(`${user} received $${amt}`);
  render();
}
function addAllCommand(modTags, amtStr){
  if(!isModOrBroadcaster(modTags)) return;
  const amt=Math.floor(+amtStr||0); if(amt<=0){ flashMessage('Usage: !addall <amt>'); return; }
  queue.forEach(u=>{ ensureBalance(u); balances[u]+=amt; });
  flashMessage(`Added $${amt} to everyone in queue`);
  render();
}

/* ===================== ROUND FLOW ===================== */
function preRoundBetSummary(names){
  const parts = names.map(n=>`${n} $${bets[n]??10}`);
  const el = $('betSummary');
  el.textContent = parts.join(' · ');
  el.style.display = parts.length ? 'block' : 'none';
}

function startRound(){
  if(inRound) return;
  if(queue.length===0){ $('roundInfo').textContent='No players queued — type !join'; return; }
  // lock mode at click
  lockedMode = playMode;
  inRound = true;
  $('modeBtn').disabled = true;

  // seat everyone in queue
  const entrants = [...queue];
  queue = [];

  // build dealer & hands
  dealer = {hand:[draw(),draw()], reveal:false};
  activePlayers = entrants.map(u=>({
    name:u, hand:[draw(),draw()], result:null, done:false, elim:false, timeLeft:TURN_TIMEOUT, log:[]
  }));

  // lock bets, deduct at start
  activePlayers.forEach(p=>{
    ensureBalance(p.name);
    let b = bets[p.name]; if(!b) b=10;
    b = Math.max(10, Math.floor(b));
    if(b>balances[p.name]) b = balances[p.name]; // all-in bound
    bets[p.name] = b;
    balances[p.name] -= b;               // deduct now
    // earnings = profit tracker; losing the bet reduces profit later; wins add +bet; push +0
  });

  // pre-round bet summary strip
  preRoundBetSummary(entrants);

  $('roundInfo').textContent = `Round started — Mode: ${lockedMode==='turn'?'Turn-Based':'All-at-Once'}`;
  turnIdx = 0;

  // timers
  if(lockedMode==='turn'){
    startTurnTimer();
  }else{
    activePlayers.forEach(p=>{
      p.timer = setInterval(()=>{
        if(!inRound) { clearInterval(p.timer); return; }
        if(p.done || p.elim) { clearInterval(p.timer); return; }
        p.timeLeft--;
        if(p.timeLeft<=0){
          p.elim=true; p.done=true; p.result={type:'lose', text:'⏰ Timeout'};
          addLog(p,'Timeout');
          maybeDealerPhase();
          clearInterval(p.timer);
        }
        render();
      },1000);
    });
  }
  render();
}

function startTurnTimer(){
  clearInterval(turnTimer);
  const p = activePlayers[turnIdx];
  if(!p){ dealerPhase(); return; }
  p.timeLeft = TURN_TIMEOUT;
  turnTimer = setInterval(()=>{
    if(!inRound){ clearInterval(turnTimer); return; }
    p.timeLeft--;
    if(p.timeLeft<=0){
      p.elim=true; p.done=true; p.result={type:'lose', text:'⏰ Timeout'};
      addLog(p,'Timeout');
      nextTurnOrDealer();
    }
    render();
  },1000);
}

function nextTurnOrDealer(){
  clearInterval(turnTimer);
  turnIdx++;
  if(turnIdx < activePlayers.length){
    startTurnTimer(); render();
  }else{
    dealerPhase();
  }
}

function maybeDealerPhase(){
  if(lockedMode==='all'){
    if(activePlayers.every(p=>p.done || p.elim)) dealerPhase();
  }
}

/* ===================== PLAYER ACTIONS ===================== */
function onHit(user){
  if(!inRound) return;
  const idx = (lockedMode==='turn') ? turnIdx
    : activePlayers.findIndex(p=>!p.done && !p.elim && p.name.toLowerCase()===user.toLowerCase());
  if(idx<0) return;
  const p = activePlayers[idx];
  if(lockedMode==='turn' && p.name.toLowerCase()!==user.toLowerCase()) return;
  if(p.done || p.elim) return;

  const c = draw(); p.hand.push(c);
  addLog(p, `Hit (${c.r}${c.s})`);
  const v = bestValue(p.hand);
  if(v>21){
    p.elim=true; p.done=true; p.result={type:'lose', text:'❌ Busted'};
    addLog(p,'Busted');
    if(lockedMode==='turn'){ nextTurnOrDealer(); }
    else { maybeDealerPhase(); }
  }
  render();
}

function onStand(user){
  if(!inRound) return;
  const idx = (lockedMode==='turn') ? turnIdx
    : activePlayers.findIndex(p=>!p.done && !p.elim && p.name.toLowerCase()===user.toLowerCase());
  if(idx<0) return;
  const p = activePlayers[idx];
  if(lockedMode==='turn' && p.name.toLowerCase()!==user.toLowerCase()) return;
  if(p.done || p.elim) return;

  p.done=true; p.result={type:'push', text:'Stood'};
  addLog(p,'Stand');
  if(lockedMode==='turn'){ nextTurnOrDealer(); }
  else { maybeDealerPhase(); }
  render();
}

/* ===================== DEALER & SETTLEMENT ===================== */
function dealerPhase(){
  // stop timers
  clearInterval(turnTimer);
  activePlayers.forEach(p=>{ if(p.timer) clearInterval(p.timer); });

  dealer.reveal = true;
  let v = bestValue(dealer.hand);
  // Dealer stands on soft 17 (classic: hit soft 17? We'll stand on soft 17)
  while(v<17 || (v===17 && isSoft(dealer.hand)===false && v<17)){ // ensure >=17
    dealer.hand.push(draw());
    v = bestValue(dealer.hand);
  }
  const dVal = bestValue(dealer.hand);

  // settle
  let lines=[`Dealer: ${dVal}`];
  activePlayers.forEach(p=>{
    const pv = bestValue(p.hand);
    const b = Math.max(10, bets[p.name]||10);

    if(p.elim){ // timed out / busted earlier: no return
      earnings[p.name]=(earnings[p.name]||0)-b; // net loss
      lines.push(`${p.name}: Lost`);
      return;
    }
    if(pv>21){ // bust
      p.result={type:'lose', text:`Lose (-$${b})`};
      addLog(p,'Lost');
      earnings[p.name]=(earnings[p.name]||0)-b;
      lines.push(`${p.name}: Busted`);
      return;
    }

    if(dVal>21 || pv>dVal){ // win
      balances[p.name] += b*2;                 // return 2x (we deducted at start)
      p.result={type:'win', text:`Win +$${b}`};
      addLog(p,`Win +$${b}`);
      earnings[p.name]=(earnings[p.name]||0)+b;
      lines.push(`${p.name}: Win (+${b})`);
    } else if(pv<dVal){ // lose
      p.result={type:'lose', text:`Lose (-$${b})`};
      addLog(p,'Lost');
      earnings[p.name]=(earnings[p.name]||0)-b;
      lines.push(`${p.name}: Lost`);
    } else { // push
      balances[p.name] += b;                   // refund
      p.result={type:'push', text:'Push (refund)'};
      addLog(p,'Push');
      // earnings 0 change
      lines.push(`${p.name}: Push`);
    }
  });

  saveEarnings();
  $('roundInfo').textContent='Round finished';
  inRound=false;
  lockedMode=null;
  $('modeBtn').disabled = false;

  // clear bets for finished players
  bets = {};
  // show summary
  flashMessage(lines.join('<br>'));
  // hide bet summary
  $('betSummary').style.display='none';
  render();
}

/* ===================== TWITCH CONNECT & COMMANDS ===================== */
function pushChat(name, msg){
  const cb=$('chatBox'); const d=document.createElement('div');
  d.className='msg'; d.innerHTML=`<b>${name}:</b> ${msg}`;
  cb.appendChild(d); cb.scrollTop=cb.scrollHeight;
}

function connectTwitch(channel){
  try{ if(client) client.disconnect(); }catch(_){}
  connectedChannel = channel;
  earningsBucketKey = `bjEarnings:${channel.toLowerCase()}`;
  loadEarnings();
  client = new tmi.Client({connection:{secure:true,reconnect:true},channels:[channel]});
  client.connect().then(()=>{$('conn').textContent=`Connected: ${channel}`;}).catch(()=>{$('conn').textContent='Not connected';});
  client.on('message',(chan,tags,msg,self)=>{
    if(self) return;
    const name = tags['display-name'] || tags.username;
    const text = msg.trim();
    pushChat(name,text);

    const parts = text.split(/\s+/);
    const cmd = (parts[0]||'').toLowerCase();

    if(cmd==='!join') joinCommand(name);
    else if(cmd==='!leave') leaveCommand(name);
    else if(cmd==='!bet') betCommand(name, parts[1]);
    else if(cmd==='!give') giveCommand(name, parts[1], parts[2]);
    else if(cmd==='!add') addCommand(tags, parts[1], parts[2]);
    else if(cmd==='!addall') addAllCommand(tags, parts[1]);
    else if(cmd==='!money') flashMessage(`${name}: $${balances[name]??START_BALANCE}`);
    else if(cmd==='!hit') onHit(name);
    else if(cmd==='!stand') onStand(name);
  });
}

/* ===================== CONTROLS ===================== */
$('connectBtn').onclick=()=>{const ch=norm($('channelInput').value); if(ch) connectTwitch(ch);};
$('startBtn').onclick=startRound;
$('stopBtn').onclick=()=>{
  // cancel current round safely
  inRound=false; lockedMode=null; $('modeBtn').disabled=false;
  clearInterval(turnTimer);
  activePlayers.forEach(p=>{ if(p.timer) clearInterval(p.timer); });
  $('roundInfo').textContent='Round stopped';
  $('betSummary').style.display='none';
  render();
};
$('resetBalancesBtn').onclick=()=>{
  // Force active players back to queue, clear bets and hands
  activePlayers.forEach(p=>{
    balances[p.name]=START_BALANCE;
    if(!queue.includes(p.name)) queue.push(p.name);
  });
  bets={};
  inRound=false; lockedMode=null; $('modeBtn').disabled=false;
  clearInterval(turnTimer);
  activePlayers.forEach(p=>{ if(p.timer) clearInterval(p.timer); });
  activePlayers=[];
  dealer={hand:[],reveal:false};
  $('roundInfo').textContent='Balances reset; players re-queued';
  $('betSummary').style.display='none';
  flashMessage('Balances reset & bets cleared');
  render();
};
$('resetEarningsBtn').onclick=()=>{
  earnings={}; saveEarnings(); flashMessage('Leaderboard reset');
  renderEarnings();
};
$('modeBtn').onclick=()=>{
  if(inRound) return;
  playMode = (playMode==='turn') ? 'all' : 'turn';
  $('modeBtn').textContent = 'Mode: ' + (playMode==='turn'?'Turn-Based':'All-at-Once');
  updateModeNote();
};

/* ===================== INIT ===================== */
(function init(){
  buildShoe();
  const p=new URLSearchParams(location.search);
  const ch=p.get('channel');
  if(ch){ $('channelInput').value=ch; connectTwitch(ch); }
  renderEarnings();
  render();
})();
</script>
</body>
</html>
